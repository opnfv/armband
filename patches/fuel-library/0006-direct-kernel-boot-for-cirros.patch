From: Stanislaw Kardach <stanislaw.kardach@caviumnetworks.com>
Date: Tue, 15 Mar 2016 15:01:34 +0100
Subject: [PATCH] direct kernel boot for cirros

---
 .../osnailyfacter/modular/astute/upload_cirros.rb  | 51 +++++++++++++++++++++-
 1 file changed, 49 insertions(+), 2 deletions(-)

diff --git a/deployment/puppet/osnailyfacter/modular/astute/upload_cirros.rb b/deployment/puppet/osnailyfacter/modular/astute/upload_cirros.rb
index 53d75fc..8a75356 100755
--- a/deployment/puppet/osnailyfacter/modular/astute/upload_cirros.rb
+++ b/deployment/puppet/osnailyfacter/modular/astute/upload_cirros.rb
@@ -56,7 +56,7 @@ def image_list
     fields = line.split('|').map { |f| f.chomp.strip }
     next if fields[1] == 'ID'
     next unless fields[2]
-    images << {fields[2] => fields[6]}
+    images << {fields[2] => { :id => fields[1], :status => fields[6]}}
   end
   {:images => images, :exit_code => return_code}
 end
@@ -78,6 +78,15 @@ EOF
   [ stdout, return_code ]
 end
 
+# Calls glance update-image with a given property and value
+def update_image(image_id, property, value)
+  command = "/usr/bin/glance image-update --#{property} #{value} #{image_id}"
+  puts command
+  stdout = `#{command}`
+  return_code = $?.exitstatus
+  [ stdout, return_code ]
+end
+
 # check if Glance is online
 # waited until the glance is started because when vCenter used as a glance
 # backend launch may takes up to 1 minute.
@@ -93,7 +102,7 @@ end
 # if it have not been already uploaded
 def upload_image(image)
   list_of_images = image_list
-  if list_of_images[:images].include?(image['img_name'] => "active") && list_of_images[:exit_code] == 0
+  if list_of_images[:images].select { |k,v| k == image['img_name'] and v[:status] == "active" } && list_of_images[:exit_code] == 0
     puts "Image '#{image['img_name']}' is already present!"
     return 0
   end
@@ -114,6 +123,43 @@ def upload_image(image)
   return return_code
 end
 
+# For each disk image try to find a kernel and initramfs images and
+# attach then to it via kernel_id and ramdisk_id glance properties.
+def connect_dependant_images(images)
+  # for each image
+  # get image id from glance
+  img_list = image_list
+  return_code = img_list[:exit_code]
+  if return_code == 0
+    images.each do |image|
+      img_list[:images].each do |k,v|
+        if k == image['img_name']
+          image['id'] = v[:id]
+        end
+      end
+    end
+    # for each image that is not in [aki, ari]
+    images.each do |image|
+      next if ['aki', 'ari'].include?(image['disk_format'])
+      images.each do |i|
+        # find aki/ari image whose name starts with this image's name
+        if i['img_name'].start_with?(image['img_name'])
+          ret = 0
+          if i['disk_format'] == 'aki'
+            _, ret = update_image(image['id'], 'property',
+                                        "kernel_id=#{i['id']}")
+          elsif i['disk_format'] == 'ari'
+            _, ret = update_image(image['id'], 'property',
+                                        "ramdisk_id=#{i['id']}")
+          end
+          return_code += ret
+        end
+      end
+    end
+  end
+  return return_code
+end
+
 ########################
 
 wait_for_glance
@@ -122,6 +168,7 @@ errors = 0
 test_vm_images.each do |image|
   errors += upload_image(image)
 end
+errors = connect_dependant_images(test_vm_images) unless errors != 0
 
 exit 1 unless errors == 0
 
