::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
: Copyright (c) 2017 Enea AB and others.
:
: All rights reserved. This program and the accompanying materials
: are made available under the terms of the Apache License, Version 2.0
: which accompanies this distribution, and is available at
: http://www.apache.org/licenses/LICENSE-2.0
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
From: Alexandru Avadanii <Alexandru.Avadanii@enea.com>
Date: Thu, 19 Jan 2017 23:03:54 +0100
Subject: [PATCH] nova: libvirt: fix delete instance with nvram

Backported from [1].

Closes-bug: 1567807

[1] https://review.openstack.org/#/q/
    539d381434ccadcdc3f5d58c2705c35558a3a065

Signed-off-by: Alexandru Avadanii <Alexandru.Avadanii@enea.com>
---
 .../files/nova-libvirt-delete-with-nvram.patch     | 70 ++++++++++++++++++++++
 .../openstack_tasks/manifests/roles/compute.pp     | 12 ++++
 2 files changed, 82 insertions(+)
 create mode 100644 deployment/puppet/openstack/files/nova-libvirt-delete-with-nvram.patch

diff --git a/deployment/puppet/openstack/files/nova-libvirt-delete-with-nvram.patch b/deployment/puppet/openstack/files/nova-libvirt-delete-with-nvram.patch
new file mode 100644
index 0000000..5d4f67c
--- /dev/null
+++ b/deployment/puppet/openstack/files/nova-libvirt-delete-with-nvram.patch
@@ -0,0 +1,70 @@
+From: Kevin Zhao <kevin.zhao@linaro.org>
+Date: Thu, 5 Jan 2017 21:32:41 +0000
+Subject: [PATCH] libvirt: fix nova can't delete the instance with nvram
+
+Currently libvirt needs a flag when deleting an VM with a nvram file,
+without which nova can't delete an instance booted with UEFI. Add
+deletion flag for NVRAM. Also add a test case.
+
+[ Alexandru Avadanii ]
+Removed chunks affecting tests and adapted for OPNFV Armband.
+
+Signed-off-by: Alexandru Avadanii <Alexandru.Avadanii@enea.com>
+Co-authored-by: Derek Higgins <derekh@redhat.com>
+Change-Id: I46baa952b6c3a1a4c5cf2660931f317cafb5757d
+Closes-Bug: #1567807
+---
+
+diff --git a/virt/libvirt/driver.py b/virt/libvirt/driver.py
+--- a/virt/libvirt/driver.py
++++ b/virt/libvirt/driver.py
+@@ -903,7 +903,8 @@ class LibvirtDriver(driver.ComputeDriver):
+         try:
+             guest = self._host.get_guest(instance)
+             try:
+-                guest.delete_configuration()
++                support_uefi = self._has_uefi_support()
++                guest.delete_configuration(support_uefi)
+             except libvirt.libvirtError as e:
+                 with excutils.save_and_reraise_exception():
+                     errcode = e.get_error_code()
+@@ -1241,7 +1242,8 @@ class LibvirtDriver(driver.ComputeDriver):
+             #             If any part of this block fails, the domain is
+             #             re-defined regardless.
+             if guest.has_persistent_configuration():
+-                guest.delete_configuration()
++                support_uefi = self._has_uefi_support()
++                guest.delete_configuration(support_uefi)
+
+             # Start copy with VIR_DOMAIN_REBASE_REUSE_EXT flag to
+             # allow writing to existing external volume file
+@@ -1760,7 +1762,8 @@ class LibvirtDriver(driver.ComputeDriver):
+             #             If any part of this block fails, the domain is
+             #             re-defined regardless.
+             if guest.has_persistent_configuration():
+-                guest.delete_configuration()
++                support_uefi = self._has_uefi_support()
++                guest.delete_configuration(support_uefi)
+
+             # NOTE (rmk): Establish a temporary mirror of our root disk and
+             #             issue an abort once we have a complete copy.
+diff --git a/virt/libvirt/guest.py b/virt/libvirt/guest.py
+--- a/virt/libvirt/guest.py
++++ b/virt/libvirt/guest.py
+@@ -262,11 +262,13 @@ class Guest(object):
+                 yield VCPUInfo(
+                     id=vcpu[0], cpu=vcpu[3], state=vcpu[1], time=vcpu[2])
+
+-    def delete_configuration(self):
++    def delete_configuration(self, support_uefi=False):
+         """Undefines a domain from hypervisor."""
+         try:
+-            self._domain.undefineFlags(
+-                libvirt.VIR_DOMAIN_UNDEFINE_MANAGED_SAVE)
++            flags = libvirt.VIR_DOMAIN_UNDEFINE_MANAGED_SAVE
++            if support_uefi:
++                flags |= libvirt.VIR_DOMAIN_UNDEFINE_NVRAM
++            self._domain.undefineFlags(flags)
+         except libvirt.libvirtError:
+             LOG.debug("Error from libvirt during undefineFlags. %d"
+                       "Retrying with undefine", self.id)
diff --git a/deployment/puppet/openstack_tasks/manifests/roles/compute.pp b/deployment/puppet/openstack_tasks/manifests/roles/compute.pp
index f6e6698..dd0c034 100644
--- a/deployment/puppet/openstack_tasks/manifests/roles/compute.pp
+++ b/deployment/puppet/openstack_tasks/manifests/roles/compute.pp
@@ -301,6 +301,18 @@ class openstack_tasks::roles::compute {
     unless  => "patch -p1 -R -N --dry-run < ${nova_path}/libvirt-vga-console.patch",
     cwd     => $nova_path,
     require => [Package['patch']],
+  } ->
+  # FIXME(armband): Backport fix: nova delete instance with nvram
+  file { "${nova_path}/nova-libvirt-delete-with-nvram.patch":
+    ensure => "file",
+    source => "puppet:///modules/openstack/nova-libvirt-delete-with-nvram.patch",
+  } ->
+  exec { 'nova libvirt delete instance with nvram':
+    path    => ['/usr/bin'],
+    command => "patch -p1 < ${nova_path}/nova-libvirt-delete-with-nvram.patch",
+    unless  => "patch -p1 -R -N --dry-run < ${nova_path}/nova-libvirt-delete-with-nvram.patch",
+    cwd     => $nova_path,
+    require => [Package['patch']],
   }

   class { '::nova::cache':
